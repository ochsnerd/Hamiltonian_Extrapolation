from abc import ABC, abstractmethod
from typing import List
from random import Random
from itertools import combinations

import numpy as np

from mpmath import sqrt
from qiskit.quantum_info import PauliTable

from .matrices import Matrix, norm_mpmath, commutator, nocommute


class NoncommutingMatrixGenerator(ABC):
    def __init__(self, dim: int) -> None:
        self.N = dim

    def set_dim(self, dim: int) -> None:
        self.N = dim

    def generate(self, J: int) -> List[Matrix]:
        """Return a list containing J noncommuting matrices."""
        assert self._possible_to_generate(J), (f"Can't generate {J} pairwise noncommuting "
                                               f"matrices of type {type(self).__name__}")
        self._reset()

        matrices = [self._generate_single_matrix() for _ in range(J)]
        while(not nocommute(matrices)):
            matrices = [self._generate_single_matrix() for _ in range(J)]

        return matrices

    @abstractmethod
    def _generate_single_matrix(self) -> Matrix:
        """Return a single matrix."""
        ...

    @abstractmethod
    def _reset(self) -> None:
        """Reset internal state.

        Ensure a new call to self.generate()
        with the same argument gives the same
        sequence of matrices.
        """
        ...

    @abstractmethod
    def _possible_to_generate(self, J: int) -> bool:
        """Return True if it's possible to generate J noncommuting matrices."""
        ...

    @abstractmethod
    def __str__(self) -> str:
        ...


class Random_1s_noncommuting_MatrixGenerator(NoncommutingMatrixGenerator):
    """Create a sequence of random, noncommuting column-1-sparse matrices.

    The matrices are generated by, for every column, picking a random row
    and inserting a random number:

    R = sum_{i=0}^{N-1} a_i e_i e_{r_i}^T,

    where a_i is drawn from U([0,1)), and r_i from U({0,1,...,N-1})
    """
    def __init__(self, dim: int, seed: int = 2) -> None:
        super().__init__(dim)
        self.seed = seed
        self.random = Random()

    def _generate_single_matrix(self) -> Matrix:
        # exactly one nonzero entry per column
        mat = Matrix(self.N, self.N)
        for col_ind in range(self.N):
            row_ind = self.random.randrange(self.N)
            mat[row_ind, col_ind] = self.random.random()
        return mat

    def _reset(self) -> None:
        self.random.seed(self.seed)

    def _possible_to_generate(self, J: int) -> bool:
        # it's possible to generate an arbitrary
        # number of random matrices of this type,
        # it might just take some tries.
        return True

    def __str__(self) -> str:
        return f"r1s_N={self.N}_s={self.seed}"


class Corner_1s_noncommuting_MatrixGenerator(NoncommutingMatrixGenerator):
    """Create a sequence of column-1-sparse corner- matrices


    A NxN 'corner 1-sparse matrix' is of the form
    C_N(x) =
    I_{N-1}      | [x, 0, ..., 0]^T
    -------------+-----------------
    [0, ..., 0]  | 0

    and has the property
    |[C_N(x), C_N(y)]| = |x-y|.

    The generate-method returns a list of C_N((j+1) * self.step),
    where j is the position of the matrix in the list.
    """
    def __init__(self, dim: int, step: float = 1) -> None:
        super().__init__(dim)
        self.step = step
        self.j = 0

    def _generate_single_matrix(self) -> Matrix:
        self.j += 1
        col = np.zeros((self.N-1, 1))
        col[0, 0] = self.step * self.j
        row = np.zeros((1, self.N-1))
        C = np.block([
            [np.identity(self.N-1), col],
            [row,                0]])
        return Matrix(C)

    def _reset(self) -> None:
        self.j = 0

    def _possible_to_generate(self, J: int) -> bool:
        return True

    def __str__(self) -> str:
        return f"c1s_N={self.N}_s={self.step}"


class Poisson_Decomp_MatrixGenerator(NoncommutingMatrixGenerator):
    # Based on Carrera2020: eq (17)ff
    def __init__(self, dim: int, a: float = 2, b: float = -1) -> None:
        # a is not actually used since the diagonal part commutes
        self._verify_dim(dim)
        super().__init__(dim)
        self.a = a
        self.b = b

        self._reset()

    def _verify_dim(self, dim: int) -> None:
        assert dim & (dim - 1) == 0, "dim has to be a power of 2"

        # get number of qubits by converting to binary string, dropping format
        # specifier, reversing order and getting index of the only 1
        n_qb = bin(dim)[2:][::-1].index('1')
        assert n_qb >= 3, "Need at least 3 qubits to get noncommuting terms"

    def _generate_single_matrix(self) -> Matrix:
        self.generate_H2 = not self.generate_H2
        if self.generate_H2:
            X = np.array([[0, 1], [1, 0]])
            # we checked that self.N is a power of two,
            # so integer division is fine here
            return Matrix(self.b * np.kron(np.identity(self.N // 2), X))
        # generate H_3
        H_3 = np.zeros((self.N, self.N))
        for j in range(1, self.N-2, 2):
            H_3[j+1, j] = self.b

        return Matrix(H_3 + H_3.T)

    def _reset(self) -> None:
        self.generate_H2 = False

    def _possible_to_generate(self, J: int) -> bool:
        return J <= 2

    def __str__(self) -> str:
        return f"poiss_N={self.N}"


class Heisenberg_MatrixGenerator(NoncommutingMatrixGenerator):
    def __init__(self, dim: int) -> None:
        super().__init__(dim)
        self.set_dim(dim)

        self._reset()

    def set_dim(self, dim: int) -> None:
        self._verify_dim(dim)
        self.N = dim
        self.n_qb = bin(dim)[2:][::-1].index('1')

        #recompute terms
        self.terms = self._compute_terms()

    def _verify_dim(self, dim: int) -> None:
        assert dim & (dim - 1) == 0, "dim has to be a power of 2"

        # get number of qubits by converting to binary string, dropping format
        # specifier, reversing order and getting index of the only 1
        n_qb = bin(dim)[2:][::-1].index('1')
        assert n_qb >= 3, "Need at least 3 qubits to get noncommuting terms"

    def _generate_single_matrix(self) -> Matrix:
        i = self.index
        self.index = (self.index + 1) % len(self.terms)
        return self.terms[i]

    def _reset(self) -> None:
        self.index = 0

    @abstractmethod
    def _compute_terms(self) -> List[Matrix]:
        ...


class Heisenberg_XYZ_MatrixGenerator(Heisenberg_MatrixGenerator):
    # Based on (125) in Childs2021, but excluding random field
    def __init__(self, dim: int) -> None:
        super().__init__(dim)

    def _compute_terms(self) -> List[Matrix]:
        I = "I" * self.n_qb
        pauli_strings = [[], [], []]
        for j in range(self.n_qb - 1):
            for interaction_term, pauli_string in zip(("XX", "YY", "ZZ"), pauli_strings):
                pauli_string += [I[:j] + interaction_term + I[j+2:]]

        return [Matrix(sum(PauliTable.from_labels(ps).to_matrix()))
                for ps in pauli_strings]

    def _possible_to_generate(self, J: int) -> bool:
        return J <= 3

    def __str__(self) -> str:
        return f"heisXYZ_N={self.N}"


class Heisenberg_EO_MatrixGenerator(Heisenberg_MatrixGenerator):
    # Based on (123), (124) in Childs2021, but excluding random field
    def __init__(self, dim: int) -> None:
        super().__init__(dim)

    def _compute_terms(self) -> None:
        I = "I" * self.n_qb
        pauli_strings = [[], []]
        for j in range(0, self.n_qb - 1, 2):
            for interaction_term in ("XX", "YY", "ZZ"):
                pauli_strings[0] += [I[:j] + interaction_term + I[j+2:]]
                pauli_strings[1] += [I[:j+1] + interaction_term + I[j+3:]]

        return [Matrix(sum(PauliTable.from_labels(ps).to_matrix()))
                for ps in pauli_strings]

    def _possible_to_generate(self, J: int) -> bool:
        return J <= 2

    def __str__(self) -> str:
        return f"heisEO_N={self.N}"


class NormalizedMatrixGenerator:
    """Decorator for a NoncommutingMatrixGenerator.

    Enforces the condition
        sum_{i<j} |[H_i, H_j]| = 1.
    """
    def __init__(self, decorated: NoncommutingMatrixGenerator) -> None:
        self.d = decorated

    def set_dim(self, dim: int) -> None:
        self.d.set_dim(dim)

    def generate(self, J: int) -> List[Matrix]:
        matrices = self.d.generate(J)

        if J > 1:
            # for J == 1 there are no commutators to normalize
            sum_of_commutators = sum(map(lambda pair: norm_mpmath(commutator(*pair)),
                                         combinations(matrices, 2)))

            assert sum_of_commutators > 1e-9, "generated matrices almost commute"

            for i, m in enumerate(matrices):
                matrices[i] = m / sqrt(sum_of_commutators)

        return matrices

    def __str__(self) -> str:
        return "norm_" + self.d.__str__()
